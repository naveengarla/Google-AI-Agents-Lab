Welcome to the deep dive. Today we're really getting into something exciting. The architecture for AI agents. That's right. We're focusing on the day one white paper from that 5day of AI agents intensive course by Google X Kaggle. Exactly. This feels like the guide for anyone building with generative AI moving you know beyond just simple demos. Absolutely. It's about building robust productionready systems. So let's talk about that shift. What's the big picture change here? Well, it's fundamental. Think about AI. Historically, it was mostly passive, right? Answering questions, translating, responding to a prompt, precisely. Now, we're talking about autonomous, goaloriented AI agents. These things don't just talk. They plan, they act, they solve complex problems over multiple steps without someone holding their hand the whole time. Exactly. That's the autonomy part. They execute actions in the world to hit a goal. Okay. So, let's unpack that. The white paper breaks down the agent anatomy into three core parts. What are they? Right. You've got the model, which is like the brain. Then the tools. Think of those as the hands. And the third piece, the orchestration layer. That's the conductor pulling it all together. Let's start with the model, the brain. It's the LLM, right? But what's its specific job in an agent? So yes, it's your core language model, your reasoning engine. But its key function here is really about managing the context window. Managing context. How? So it's constantly deciding what's important right now. Information comes from the mission itself, from memory, from what the tools just did. The model curates all that. It decides what input matters for the next thought process. Okay? So the model thinks, but it needs the tools to actually do anything. That's it. The tools are the connection to the outside world or even internal systems. They could be APIs, specific code functions, ways to access databases, vector stores. So the agent can like look up customer data or check inventory. Exactly. And crucially, the model reasons about which tool is needed for the current step in its plan. Then the orchestration layer actually calls that tool and the result from the tool. That result, the observation gets fed straight back into the model's context, ready for the next cycle of thought. Which brings us to that orchestration layer. You called it the conductor. It sounds like more than just running code. Oh, much more. It's the governor of the whole process. It manages that operational loop we mentioned. the planning, keeping track of the memory or state and executing the reasoning strategy. Reasoning strategy, like chain of thought. Yeah. Or react, which is really common for agents. React blends reasoning and acting. The agent thinks, okay, based on my goal and current info, I should do X. It acts using a tool. It observes the result. Then it reasons again based on that new info. So, it's not just blindly following a script. It's constantly thinking, acting, observing, thinking again. That's the loop. That's what makes it agentic. It's transforming the LLM from just a text generator into something that can actually accomplish complex tasks. Can you walk us through that loop? Say for a simple task, what are the key stages? Sure. Let's use the white paper example. Organize my team's travel. Step one is obvious. Get the mission. The agent gets the BLE goal. Step two, scan the scene. It looks around virtually speaking. What tools does it have? Calendar access. Booking APIs. what's relevant in its memory. Then step three, think it through. This is the planning stage. The model says, okay, for travel, first I need the team list. I should use the get team roster tool. Makes sense. Step four, take action. The orchestration layer actually calls that get team roster tool. And finally, step five, observe and iterate. The tool runs, maybe returns a list of names. that list, the observation gets added to the agents context, its working memory, and bam, it loops right back to step three, thinking, "Okay, I have the roster. What's next? Check availability." And that cycle just repeats until the overall mission, organizing the travel, is complete. It's the same process for handling something like a customer support query. Where's my order? The agent needs to plan, find order, get tracking, query, carrier, report back. Each step involves that think, act, observe cycle. Got it. That loop is fundamental. Now the white paper also talks about a taxonomy different levels of agent capability. Why is that important? Ah yeah this is crucial for actually designing and scoping your agent. You need to decide how complex it needs to be. Level zero is the baseline. What's level zero? That's just the language model on its own. No tools. It only knows what it was trained on. It can tell you about history. Maybe explain a concept. But it can't tell me the score of last night's game. Exactly. It's cut off from the present. So level one is the first real step up, the connected problem solver. This is where the tools come in, right? You connect the reasoning engine to tools. Now it has those hands. It can use a search API, check a database. It can answer the score question because it could look it up. It has real-time awareness. Okay, so level one connects to the world. What's level two? Level two is the strategic problem solver. Now we're moving beyond single simple tasks to more complex multi-art goals. The key skill here is something called context engineering. Context engineering. Yeah, it means the agent gets smart about crafting the input for each step. Take the example, find a good coffee shop halfway between two addresses. Okay, that's definitely multi-step, right? A level two agent would first use, say, a maps tool to calculate the actual halfway point coordinates. Then it takes that specific result, the coordinates or maybe the neighborhood name, and uses it to craft a very focused query for another tool like a place search API, maybe asking for coffee shops near those coordinates with a rating above 4.0. Ah, so it's using the output of one step to intelligently shape the input for the next step. Exactly. It's actively managing its own context to get better, more relevant results and avoid noise. That's clever. What about level three? Level three is the collaborative multi- aent system. This is a big jump. Now you're talking about a team of specialists. Agents start treating other agents as tools like a little company of AIS sort of. Imagine a project manager agent. It gets a complex goal like analyze competitor pricing. It doesn't do all the work itself. It delegates tasks to specialized agents, maybe a market research agent, maybe a data analysis agent. So it calls another agent's API essentially. How is that different from just calling a complex function? Good question. The difference is often the autonomy of the agent being called. The project manager delegates the goal, analyze pricing. The market research agent receives that goal and might execute its own multi-step plan using its own specialized tools and knowledge before returning a synthesized result. It's not just a simple request response. It's agent-to- agent goal delegation. Okay, that's starting to sound seriously complex, which leads us to level four. Level four, the self-evolving system. This is uh pretty much the frontier right now. Here the system can actually identify gaps in its own capabilities. It knows what it doesn't know or what it can't do. Exactly. And it can take steps to fix it. So if that project manager agent realizes it needs say real time social media sentiment analysis for the competitor research and no existing agent or tool can do it. What then it might invoke an agent creator tool to actually build a new sentiment analysis agent on the fly. Maybe configure its access permissions. everything. It's adapting and expanding its own toolkit. Wow. Okay, that's a powerful vision. Let's shift gears a bit. If we want to build these, especially beyond level one or two, how do we make them work reliably in production? That non-determinism seems tricky. It is tricky and it starts with model selection. You need to move beyond just looking at generic benchmark scores. So, the biggest model isn't always the best. Not for an agent. You need the model that shows the best reasoning and crucially the most reliable tool use for your specific tasks. This often leads to a strategy called model routing. Routing like sending different tasks to different models. Precisely. You might use a really powerful maybe more expensive model like Gemini 1.5 Pro for the complex planning steps or high stakes decisions. But for simpler highvolume tasks within the agents workflow like summarizing text or extracting a simple piece of data you might route that to a faster cheaper model like Gemini 1.5 flash. It's about optimizing performance and cost. Smart resource allocation. What about the tools themselves? You mentioned retrieval and action right for retrieving information. Grounding the agent in facts is key. So you use arg retrieval augmented generation often with vector databases for searching unstructured documents or NL2SQL tools so the agent can query your structured databases using natural language and for taking action that's typically done using APIs wrapped as tools scheduling a meeting via a calendar API updating a CRM record maybe even executing code some agents can write and run Python scripts in a secure sandbox environment to handle really dynamic tasks But for the model to use these tools reliably, it needs to know how to call them, right? Absolutely critical. This is where function calling comes in. The tools need clear descriptions like an open API spec. This tells the model exactly what the tool does, what parameters it needs like order it or custom email, and what format the output will be in. So the model can generate the correct API call. Yes. And just as importantly, it can accurately understand the response from the tool. Without that structured communication, the whole loop can break down. Okay. Let's swing back to the orchestration layer. We know it runs the loop, but what else does it handle? It's also responsible for defining the agents persona and its operating rules. This is often done via a system prompt or a constitution, like telling it you are a helpful support agent for Acme Corp. Never give financial advice. Exactly. Setting the boundaries, the personality. And the other big job is managing memory. Memory. Yeah. You typically distinguish between short-term memory and long-term memory. Short-term is like the agent's scratch pad for the current task. The running history of action observation pairs in the current loop and long-term long-term memory persists across sessions. It's how the agent remembers preferences, past interactions or knowledge it gained previously. Architecturally, this is often implemented as just another tool, usually a rag system talking to a vector database where memories are stored and retrieved. Okay, so we have the model tools orchestration memory. But these things are still unpredictable sometimes. How do you handle testing and debugging what the white paper calls agent ops? Yeah, this is a huge shift from traditional software testing. You can't just assert output expected output because the output might be perfectly valid even if it's phrased slightly differently each time. So what do you do instead? You evaluate quality. A common technique is using an LM as judge. You use another powerful language model. give it a detailed rubric and have it assess the agents output. You use an AI to check the AI essentially. Yes. Does the response meet the requirements? Is it factually grounded? Did it follow the negative constraints? You run these evaluations automatically against a golden data set of test scenarios. And when it fails, how do you figure out why? Debugging is tough. That's where observability tools, specifically open telemetry traces, are incredibly valuable. A trace gives you a detailed step-by-step log of the agents entire thought process, its trajectory, like a flight recorder. Exactly. It shows the prompt at each step, the reasoning, which tool was chosen, the exact parameters sent to the tool, the observation received back, everything. It lets you pinpoint where things went wrong in that complex loop. That sounds essential. What about feedback from actual users? Human feedback is gold dust. The process should be. When a user reports a failure or a weird behavior, you don't just fix it. You capture that scenario, reproduce it, and turn it into a new permanent test case in your golden data set. So, you vaccinate the system against that specific error recurring. Precisely. It drives continuous improvement and makes the agent more robust over time. Let's talk security and scaling. Giving these agents the power to act using tools. That sounds potentially risky. It is. There's a fundamental tension, the trust trade-off. More utility often means more potential risk. Security needs multiple layers, what's called defense in depth. Like what? You need hard-coded guard rails, simple rules enforced by code, like a policy engine blocking any API call that tries to spend over a certain limit. Yeah. But you also layer on AI based guard models. More AI checking AI. Yeah. These models specifically look for risky steps before execution. Is the agent about to leak sensitive data? Is it trying to perform a forbidden action? the guard model flags it potentially stopping the action. And a key part of this is giving the agent its own identity. Absolutely fundamental. An agent isn't just acting as the user. It's a new actor in your system. It needs its own secure, verifiable identity. Think of it like a digital passport, often using standards like sexbf. Why is that so important? Because it allows for leech privilege permissions. You can grant the sales agent access to the CRM tool, but explicitly deny it access to the HR database. The agents identity determines what it's allowed to touch. That makes sense for individual agents, but what happens when you scale up to level three or four with potentially dozens or hundreds of agents interacting? Agent sprawl. Agent sprawl is a real risk. Management becomes key. You need agent governance, typically through a central control plane or gateway. A single point of control. Yes. All traffic user to agent, agent to tool, even agent to agent communication must go through this gateway. It enforces policies, handles authentication, and gives you that crucial single pane of glass for monitoring logs, metrics, and traces across your entire agent fleet. Okay, last couple of points. How do these agents learn and evolve over time? Do they get better automatically? They need to adapt. Otherwise, their performance degrades as the world changes. Learning comes from analyzing their runtime experience. those logs and traces, user feedback, and also from external signals like updated company policies. This feedback loop fuels optimization, maybe by refining the system prompts, improving the context engineering, or even optimizing or creating new tools. And the white paper mentions simulation, an agent gym. Yeah, that's kind of the next frontier, especially for complex multi- aent systems. It's about having a dedicated safe off-production environment where you can simulate interactions, use synthetic data, maybe even involve domain experts to really stress test and optimize how agents collaborate or how they handle novel situations without impacting real users. Let's make this concrete with some examples. Google co-scientist, right? Co-scientist is a fascinating example of a level three or maybe even pushing level four system for scientific research. It acts like a virtual research collaborator. There's a supervisor agent managing the project, delegating tasks like formulating hypotheses, designing experiments, analyzing data to a whole team of specialized agents. It iterates, refineses ideas, basically mirrors a human research workflow, but potentially much faster. And Alphavolve, that sounds even more abstract. Alphavolve is definitely in the level four space. It's an AI system designed to discover and optimize algorithms. It uses the code generation power of LMS to create potential algorithms, but then combines that with an automated evolutionary process to test and improve them rigorously and it's found useful things reportedly. Yes, things like more efficient data center operations, even faster ways to do fundamental math like matrix multiplication. But the key is the partnership the AI generates solutions often as code. But humans provide the expert guidance, define what counts as a better algorithm via evaluation metrics and ensure the solutions are understandable. So wrapping this all up, it really feels like building successful agents isn't just about having the smartest model. Not at all. That's the core message. The agent is the combination of the model for reasoning, the tools for action, and the orchestration layer managing that loop. Success really hinges on the engineering rigor around it. The architecture, the governance, security, testing, observability. That's what makes it production ready. So for you listening, the takeaway is that your role is evolving. You're becoming less of just a coder and more of an architect, a director guiding these increasingly autonomous systems. Absolutely. These agents aren't just fancy automations. They have the potential to be genuinely collaborative, adaptable partners in tackling complex work. It's a powerful concept. We really encourage you to check out the Google X Kaggle course materials. Dig into that day one white paper and maybe start thinking about how you could build your own production grade agentic systems. It feels like the future is definitely